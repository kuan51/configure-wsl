name: CI - Tests and Validation

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1

jobs:
  test:
    name: Test on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, windows-2019]
        include:
          - os: windows-latest
            pwsh-version: 'latest'
          - os: windows-2019
            pwsh-version: 'latest'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup PowerShell
      shell: pwsh
      run: |
        Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor Green
        Write-Host "Operating System: $($PSVersionTable.OS)" -ForegroundColor Green
        Write-Host "Platform: $($PSVersionTable.Platform)" -ForegroundColor Green
        
    - name: Install Pester
      shell: pwsh
      run: |
        Write-Host "Installing Pester module..." -ForegroundColor Yellow
        Install-Module -Name Pester -Force -SkipPublisherCheck -Scope CurrentUser
        $pesterVersion = (Get-Module -Name Pester -ListAvailable | Sort-Object Version -Descending | Select-Object -First 1).Version
        Write-Host "Pester version installed: $pesterVersion" -ForegroundColor Green
        
    - name: Install PSScriptAnalyzer
      shell: pwsh
      run: |
        Write-Host "Installing PSScriptAnalyzer module..." -ForegroundColor Yellow
        Install-Module -Name PSScriptAnalyzer -Force -SkipPublisherCheck -Scope CurrentUser
        $psaVersion = (Get-Module -Name PSScriptAnalyzer -ListAvailable | Sort-Object Version -Descending | Select-Object -First 1).Version
        Write-Host "PSScriptAnalyzer version installed: $psaVersion" -ForegroundColor Green
        
    - name: Run PowerShell Script Analysis
      shell: pwsh
      run: |
        Write-Host "Running PSScriptAnalyzer..." -ForegroundColor Yellow
        
        # Analyze the main module file
        $analysisResults = Invoke-ScriptAnalyzer -Path "./src/ConfigureWSL.psm1" -Severity Warning,Error -Recurse
        
        if ($analysisResults) {
            Write-Host "PSScriptAnalyzer found issues:" -ForegroundColor Red
            $analysisResults | ForEach-Object {
                Write-Host "  $($_.Severity): $($_.Message) (Line $($_.Line))" -ForegroundColor Red
            }
            
            # Fail the build if there are errors
            $errorCount = ($analysisResults | Where-Object { $_.Severity -eq 'Error' }).Count
            if ($errorCount -gt 0) {
                throw "PSScriptAnalyzer found $errorCount error(s). Please fix them before continuing."
            }
            
            $warningCount = ($analysisResults | Where-Object { $_.Severity -eq 'Warning' }).Count
            Write-Host "Found $warningCount warning(s). Consider addressing them." -ForegroundColor Yellow
        } else {
            Write-Host "PSScriptAnalyzer found no issues!" -ForegroundColor Green
        }
        
    - name: Test Module Import
      shell: pwsh
      run: |
        Write-Host "Testing module import..." -ForegroundColor Yellow
        try {
            Import-Module ./src/ConfigureWSL.psd1 -Force
            $module = Get-Module ConfigureWSL
            if ($module) {
                Write-Host "Module imported successfully!" -ForegroundColor Green
                Write-Host "Module version: $($module.Version)" -ForegroundColor Green
                Write-Host "Exported functions: $($module.ExportedFunctions.Count)" -ForegroundColor Green
                $module.ExportedFunctions.Keys | ForEach-Object {
                    Write-Host "  - $_" -ForegroundColor Gray
                }
            } else {
                throw "Module import failed - module not found after import"
            }
        } catch {
            Write-Host "Module import failed: $_" -ForegroundColor Red
            throw
        } finally {
            Remove-Module ConfigureWSL -Force -ErrorAction SilentlyContinue
        }
        
    - name: Run Tests
      shell: pwsh
      run: |
        Write-Host "Running tests..." -ForegroundColor Yellow
        
        # Create test results directory
        New-Item -Path "./TestResults" -ItemType Directory -Force | Out-Null
        
        # Run tests with coverage
        $testResult = & ./tests/Invoke-Tests.ps1 -Coverage -CI -OutputPath "./TestResults"
        
        if ($testResult -ne 0) {
            throw "Tests failed with exit code: $testResult"
        }
        
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.os }}
        path: |
          TestResults/test-results.xml
          TestResults/coverage.xml
        retention-days: 30
        
    - name: Publish Test Results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Test Results (${{ matrix.os }})
        path: TestResults/test-results.xml
        reporter: java-junit
        fail-on-error: true
        
    - name: Code Coverage Report
      if: matrix.os == 'windows-latest'
      uses: codecov/codecov-action@v3
      with:
        file: ./TestResults/coverage.xml
        flags: powershell
        name: codecov-powershell
        fail_ci_if_error: false
        
  validate-scripts:
    name: Validate PowerShell Scripts
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install PSScriptAnalyzer
      shell: pwsh
      run: |
        Install-Module -Name PSScriptAnalyzer -Force -SkipPublisherCheck -Scope CurrentUser
        
    - name: Run PSScriptAnalyzer on all PS1 files
      shell: pwsh
      run: |
        Write-Host "Running PSScriptAnalyzer on all PowerShell files..." -ForegroundColor Yellow
        
        $scriptFiles = Get-ChildItem -Path . -Include "*.ps1", "*.psm1", "*.psd1" -Recurse | Where-Object {
            $_.FullName -notlike "*\.git\*" -and 
            $_.FullName -notlike "*\node_modules\*" -and
            $_.FullName -notlike "*\packages\*"
        }
        
        $allIssues = @()
        
        foreach ($file in $scriptFiles) {
            Write-Host "Analyzing: $($file.Name)" -ForegroundColor Gray
            $issues = Invoke-ScriptAnalyzer -Path $file.FullName -Severity Warning,Error
            if ($issues) {
                $allIssues += $issues
                $issues | ForEach-Object {
                    Write-Host "  $($_.Severity): $($_.Message) (Line $($_.Line))" -ForegroundColor $(if ($_.Severity -eq 'Error') { 'Red' } else { 'Yellow' })
                }
            }
        }
        
        if ($allIssues) {
            $errorCount = ($allIssues | Where-Object { $_.Severity -eq 'Error' }).Count
            $warningCount = ($allIssues | Where-Object { $_.Severity -eq 'Warning' }).Count
            
            Write-Host "`nSummary:" -ForegroundColor Cyan
            Write-Host "  Errors: $errorCount" -ForegroundColor Red
            Write-Host "  Warnings: $warningCount" -ForegroundColor Yellow
            
            if ($errorCount -gt 0) {
                throw "PSScriptAnalyzer found $errorCount error(s) across all files."
            }
        } else {
            Write-Host "No issues found in any PowerShell files!" -ForegroundColor Green
        }
        
    - name: Check PowerShell Syntax
      shell: pwsh
      run: |
        Write-Host "Checking PowerShell syntax..." -ForegroundColor Yellow
        
        $scriptFiles = Get-ChildItem -Path . -Include "*.ps1", "*.psm1" -Recurse | Where-Object {
            $_.FullName -notlike "*\.git\*"
        }
        
        $syntaxErrors = @()
        
        foreach ($file in $scriptFiles) {
            try {
                $ast = [System.Management.Automation.Parser]::ParseFile($file.FullName, [ref]$null, [ref]$null)
                if (-not $ast) {
                    $syntaxErrors += "Failed to parse: $($file.Name)"
                }
            } catch {
                $syntaxErrors += "Syntax error in $($file.Name): $($_.Exception.Message)"
            }
        }
        
        if ($syntaxErrors) {
            Write-Host "Syntax errors found:" -ForegroundColor Red
            $syntaxErrors | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
            throw "Syntax validation failed"
        } else {
            Write-Host "All PowerShell files have valid syntax!" -ForegroundColor Green
        }
        
  security-scan:
    name: Security Scan
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Security Scan
      shell: pwsh
      run: |
        Write-Host "Running basic security checks..." -ForegroundColor Yellow
        
        # Check for common security issues
        $securityIssues = @()
        
        # Check for hardcoded credentials patterns
        $credentialPatterns = @(
            'password\s*=\s*["\'][^"\']+["\']',
            'pwd\s*=\s*["\'][^"\']+["\']',
            'secret\s*=\s*["\'][^"\']+["\']',
            'token\s*=\s*["\'][^"\']+["\']',
            'key\s*=\s*["\'][^"\']+["\']'
        )
        
        $scriptFiles = Get-ChildItem -Path . -Include "*.ps1", "*.psm1" -Recurse | Where-Object {
            $_.FullName -notlike "*\.git\*"
        }
        
        foreach ($file in $scriptFiles) {
            $content = Get-Content $file.FullName -Raw
            foreach ($pattern in $credentialPatterns) {
                if ($content -match $pattern) {
                    $securityIssues += "Potential hardcoded credential in $($file.Name): $($matches[0])"
                }
            }
        }
        
        # Check for Invoke-Expression usage (potential security risk)
        foreach ($file in $scriptFiles) {
            $content = Get-Content $file.FullName -Raw
            if ($content -match 'Invoke-Expression|iex') {
                Write-Host "Warning: Invoke-Expression found in $($file.Name) - review for security implications" -ForegroundColor Yellow
            }
        }
        
        if ($securityIssues) {
            Write-Host "Security issues found:" -ForegroundColor Red
            $securityIssues | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
            throw "Security scan failed"
        } else {
            Write-Host "No obvious security issues found!" -ForegroundColor Green
        }